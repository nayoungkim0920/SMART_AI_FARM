//클래스 다이아그램
+-----------------------------------+
|               Shape               |
+-----------------------------------+
| - color: std::string              |
+-----------------------------------+
| + Shape(color: std::string = "undefined") |
| + virtual area(): double          |
| + virtual perimeter(): double     |
| + virtual name(): std::string     |
| + setColor(color: std::string)   |
| + getColor(): std::string         |
+-----------------------------------+
            /\
            |
            |
            |
            |
            |
+-----------------------------------+
|            Rectangle              |
+-----------------------------------+
| - width: double                   |
| - height: double                  |
+-----------------------------------+
| + Rectangle(width: double, height: double, color: std::string = "undefined") |
| + area(): double override         |
| + perimeter(): double override    |
| + name(): std::string override    |
+-----------------------------------+

// Shape.h
#ifndef SHAPE_H
#define SHAPE_H

#include <string>

class Shape {
private:
	std::string color;
public:
	Shape(const std::string& color = "undefined");
	virtual double area() const = 0; //순수 가상 함수
	virtual double perimeter() const = 0; //순수 가상 함수
	virtual std::string name() const = 0; //순수 가상 함수
	virtual ~Shape(); //가상 소멸자

	void setColor(const std::string& color);
	std::string getColor() const;
};

#endif //SAHPE_H

//Shape.cpp
#include "Shape.h"

Shape::Shape(const std::string& color) : color(color) {
	std::cout << "Shape 생성자" << std::endl;
}

Shape::~Shape() {
	std::cout << "Shape 소멸자" << std::endl;
}

void Shape::setColor(const std::string& color)
{
	this->color = color;
}

std::string Shape::getColor() const
{
	return color;
}

//main.cpp
#include "Rectangle.h"
#include <iostream>

int main() {
	Shape* s = new Rectangle(3, 5);
	s->setColor("red");
	std::cout << s->getColor() << std::endl;
	delete s;
}

Shape 생성자
Rectangle 생성자
red
Rectangle 소멸자
Shape 소멸자

1. Shape.h
1) 헤더가드
#ifndef SHAPE_H,#define SHAPE_H,#endif //SAHPE_H
헤더파일이 여러 번 포함되는 것을 방지 하기 위해 사용된다.
컴파일 시간 오류를 방지하고 코드의 안정성을 높인다.
다중 포함을 방지하여 컴파일 오류를 피하고, 컴파일 시간을 줄이며, 코드의 
일관성을 유지하기 위해 사용된다.

2) 색상속성
private:
    std::string color;
도형의 색상을 나타내는 color 멤버 변수를 private로 선언하여 
직접 접근을 막고, 대신 public 멤버 함수를 통해 접근한다.
정보 은닉(Information Hiding)을 통해 데이터 무결성을 유지하고,
클래스의 인터페이스와 구현을 분리하여 유지보수성과 확장성을 높인다.

3) 생성자
public":
Sahpe(const std::string& color = "undefined") : color(color);
생성자는 객체가 생성될 때 호출되며, 기본적으로 색상을 undefined로 설정.
기본 값을 제공함으로써 객체 생성 시 불필요한 초기화 코드를 줄이고
사용 편의성을 높인다.
상수참조(const std::string&)는 매개변수를 상수 참조로 받는다.
-복사방지 : 문자열을 값으로 전달하면 복사가 일어난다. 복사는 시간과 메모리
측면에서 비효율적일 수 있다. 참조를 사용하면 이러한 복사를 피할 수 있다.
-불변성 : const 키워드를 사용하면 함수 내부에서 매개변수를 수정할 수 없게
되어 원본 데이터가 변경되지 않음을 보장한다.

4) 순수가상함수
virtual doble area() const = 0;
virtual double perimeter() const = 0;
virtual str::string name() const = 0;
Shape 클래스가 추상 클래스가 되게 하며, 상속받는 파생 클래스가 반드시
이 함수들을 구현하도록 강제한다.
-다형성(Polymorphism) : 순수 가상 함수를 사용하여, 동일한 인터페이스를 통해
다양한 도형 객체를 일관되게 처리할 수 있다.
-확장성 : 새로운 도형 클래스를 추가할 때, Shape클래스를 상속받아 필요한 함수
들을 구현하기만 하면 되므로, 기존 코드를 수정할 필요 없이 기능을 확장할 수
있다.
-유연성 : 프로그램이 구체적인 도형 클래스에 의존하지 않도록 하여, 변경에
유연하게 대응할 수 있다.

5) 가상 소멸자
virtual ~Shape()
파생 클래스와 객체가 올바르게 소멸되도록 보장한다.
기본 클래스 포인터로 파생 클래스 객체를 삭제할 때, 올바른 소멸자가 호출되어
메모리 누수를 방지하고 자원을 올바르게 해제할 수 있다.
추상클래스의 소멸자가 호출되면 파생클래스의 소멸자도 호출된다.

#include "Shape.h"
#include "Rectangle.h"

int main() {
	Shape* s = new Rectangle(3, 5);
	delete s;
}

Shape 생성자
Rectangle 생성자
Rectangle 소멸자
Shape 소멸자

6) 색상 설정 및 반환 함수
void setColor(const std::string& color){
	this->color = color;
}

std::string getColor() const{
	return color;
}

-캡슐화(Capsulation) : 멤버 변수에 직접 접근하는 것을 막고, 함수를 통해
안전하게 접근할 수 있도록 한다.
-유지보수성 : 멤버 변수를 변경할 때마다 다른 코드를 수정할 필요 없이, 
해당 함수만 수정하면 되므로 유지보수가 용이하다.

2. Shape.cpp
1) 헤더파일포함
#include "Shape.h"
Shape클래스의 선언이 포함되어 있다. 이 파일을 포함함으로써 Shape 클래스의 
정의와 멤버 함수 선언을 사용할 수 있다.

2)생성자 구현
Shape::Shape(const std::string& color) : color(color) {
	std::cout << "Shape 생성자" << std::endl;
}
도형의 초기색상을 설정한다. 생성자가 호출될 때 멤버 변수를 초기화하는 
효율적인 방법이다.

3)소멸자 구현
Shape::~Shape(){
	std::cout << "Shape 소멸자" << std::endl;
}
Shape클래스의 가상 소멸자이다. 파생클래스의 소멸자가 올바르게 호출되도록
보장한다. 이 소멸자는 Shape 객체가 소멸될 때 호출된다.

4)색상설정함수구현
void Shape::setColor(const std::string& color){
	this->color = color;
}
private멤버변수인 color변수를 설정한다. 매개변수로 받은 color값을 
this포인터를 사용하여 현재 객체의 color 멤버 변수에 할당한다. 
this포인터는 멤버 함수가 호출된 객체의 주소를 가리키는 특별한 포인터로
이를 통해 멤버 변수와 매개변수의 이름이 동일하더라도 구별할 수 있다.
하지만, 변수명을 겹치지않게하고 this를 사용하여 명확히 구분하는 방식을 
더 선호한다. 코드의 가독성을 높이고 유지보수성을 향상시키는 데 도움이되며
코드베이스의 일관성을 유지하는 데 도움이된다.
-> : 포인터가 가리키는 객체의 멤버에 접근하기 위해 사용된다.

//Circle 추가
+-----------------------------------+
|               Shape               |
+-----------------------------------+
| - color: std::string              |
+-----------------------------------+
| + Shape(color: std::string = "undefined") |
| + virtual area(): double          |
| + virtual perimeter(): double     |
| + virtual name(): std::string     |
| + setColor(color: std::string)   |
| + getColor(): std::string         |
+-----------------------------------+
            /\
            |
            |
            |
            |
            |
+-----------------------------------+
|            Rectangle              |
+-----------------------------------+
| - width: double                   |
| - height: double                  |
+-----------------------------------+
| + Rectangle(width: double, height: double, color: std::string = "undefined") |
| + area(): double override         |
| + perimeter(): double override    |
| + name(): std::string override    |
+-----------------------------------+
            /\
            |
            |
            |
            |
            |
+-----------------------------------+
|              Circle               |
+-----------------------------------+
| - radius: double                  |
+-----------------------------------+
| + Circle(radius: double, color: std::string = "undefined") |
| + area(): double override         |
| + perimeter(): double override    |
| + name(): std::string override    |
+-----------------------------------+


//Circle.h

#ifndef CIRCLE_H
#define CIRCLE_H

#include "Shape.h"

class Circle : public Shape {
private:
	double radius;
public:
	Circle(double radius, const std::string& color = "undefined");
	virtual double area() const override; 
	virtual double perimeter() const override; 
	virtual std::string name() const override;
	virtual ~Circle() override;
};

#endif //CIRCLE_H

//Circle.cpp
#include "Circle.h"
#include <iostream>

const double PI = 3.141592;

Circle::Circle(double radius, const std::string& color)
	: Shape(color), radius(radius)
{
	std::cout << "Circle 생성자" << std::endl;
}

double Circle::area() const
{
	return PI * radius * radius;
}

double Circle::perimeter() const
{
	return 2 * PI * radius;
}

std::string Circle::name() const
{
	return "Circle";
}

Circle::~Circle()
{
	std::cout << "Circle 소멸자" << std::endl;
}

//main.cpp
#include "Rectangle.h"
#include "Circle.h"
#include <iostream>

int main() {
	Shape* s[2];
	s[0] = new Rectangle(3, 5);
	s[0]->setColor("red");
	std::cout << s[0]->getColor() << std::endl;

	s[1] = new Circle(2, "yellow");
	std::cout << s[1]->getColor() << std::endl;

	delete s[0];
	delete s[1];
}

Shape 생성자
Rectangle 생성자
red
Shape 생성자
Circle 생성자
yellow
Rectangle 소멸자
Shape 소멸자
Circle 소멸자
Shape 소멸자

1) 생성자
Circle::Circle(double radius, const std::string& color)
	: Shape(color), radius(radius)
생성자 몸체에 진입 하기 전에 멤버 변수가 초기화되므로 효율적이다.

//순수가상함수
1)베이스 클래스 - Shapde.h
virtual std::string name() const = 0;
2)파생클래스(순수가상함수오버라이드) - Rectangle.h
virtual std::string name() const override;
3)파생 클래스 - Square.h
std::string name();
순수가상함수를 한번더 상속받는 경우에는 해당 함수를 다시 선언할 필요가없다.
이미 베이스클래스에서 순수가상함수로 선언되었기 때문에 파생클래스에서
다시 선언할 필요가 없다. 파생클래스가 이미 해당 함수를 오버라이딩해야하기
때문이다. 

//생성자
-Shape.h
Shape(const std::string& color = "undefined");
-Shape.cpp
Shape::Shape(const std::string& color) : color(color){}

-Rectangle.h
Rectangle(double w, double h, const std::string& color="undefined");
-Rectangle.cpp
Rectangle::Rectangle(double w, double h, const std::string& color) 
	:Shape(color), width(w), height(h) {}

-Square.h
Square(double side, const std::string& color = "undefined");
-Square.cpp
Square::Square(double side, const std::string& color)
	: Rectangle(side, side, color){}

//포인터, 스마트 포인터, 벡터
1. 포인터
-다형성지원 : 기본 클래스 포인터를 사용하여 다양한 파생 클래스 객체를 처리할 수 있다.
-객체수명제어 : 동적 할당과 해체를 통해 객체의 수명을 명확하게 제어할 수 있다. 
-메모리관리 : 동적으로 할당된 메로리를 명시적으로 해제해야하며 , 이를 잊으면 메모리 
누수가 발생할 수 있다.
-코드복잡성 : 포인터를 사용하면 코드가 복잡해질 수 있으며,메모리 관리 코드가 추가된다.
2. 스마트 포인터(std::unique_ptr, std::shared_ptr등)
포인터와 유사하지만 자동으로메모리를 관리한다.
-자동메모리관리 : 객체가 더이상 사용되지 않으면 자동으로 메모리가 해제된다.
-다형성지원 : 기본 클래스 포인터를 사용하여 다양한 파생 클래스 객체를 처리할 수 있다.
-안전성 : 메모리 누수를 방지할 수 있다.
-약간의 오버헤드 : 스마트 포인터는 포인터 관리 비용이 약간 더 발생할 수 있다.
-복잡한 구문 : 기본 포인터보다 구문이 조금 더 복잡할 수 있다.
3. 벡터(std::vector)
표준 템플릿 라이브러리(STL)의 컨테이너로 동적 배열을 제공한다.
-자동 크기 조절 : 벡터는 요소가 추가되면 자동으로 크기가 조절된다.
-간편한 메모리 관리 : 벡터는 요소를 자동으로 관리하며, 요소가 제거되면 자동으로 메모리를
해제한다.
-범위기반 for ㄹ프 : 범위 기반 for 루프를 사용하여 간편하게 요소를 순회할 수 있다.
-다형성 제한 : 벡터 자체는 다형성을 직접 지원하지 않으므로, 포인터를 사용하여 다형성을
구현해야한다.-
-메모리 오버헤드 : 벡터는 크기 조절을 위해 내부적으로 메모리를 할당하고 해제할 때 약간의
오버헤드가 발생할 수 있다.

//Triangle 확장하기
//Triangle.h
#include "Shape.h"

class Triangle : public Shape {
private:
	double base;
	double height;
public:
	Triangle(double base, double height, const std::string& color = "undefined");
	virtual double area() const override;
	virtual double perimeter() const override;
	virtual std::string name() const override;
	virtual ~Triangle() override;
};

//Triangle.cpp
#include "Triangle.h"
#include <iostream>

Triangle::Triangle(double base, double height, const std::string& color)
	: Shape(color), base(base), height(height) {
	std::cout << "Triangle 생성자" << std::endl;
}

double Triangle::area() const
{
	return 0.5 * base * height;
}

double Triangle::perimeter() const
{
	return 3 * base;
}

std::string Triangle::name() const
{
	return "Triangle";
}

Triangle::~Triangle()
{
	std::cout << "Triangle 소멸자" << std::endl;
}

//main.cpp
#include "Rectangle.h"
#include "Square.h"
#include "Triangle.h"
#include <iostream>
#include <vector>

int main() {

	std::vector<Shape*> shapes;

	shapes.push_back(new Rectangle(3, 5, "red"));
	shapes.push_back(new Square(2, "green"));
	shapes.push_back(new Triangle(3, 5, "yellow"));

	for (const auto& shape : shapes) {
		std::cout << shape->name() << "의 색상: " << shape->getColor() << std::endl;
		std::cout << shape->name() << "의 면적: " << shape->area() << std::endl;
		std::cout << shape->perimeter() << "의 둘레:" << shape->perimeter() << std::endl;
	}

	for (auto& shape : shapes) {
		delete shape;
	}

	shapes.clear();

	return 0;
}

//멤버함수호출방법
//1. 생성자
shapes.push_back(new Rectangle(3, 5, "red"));
//2. setColor() 호출
shape.push_back(new Rectangle(3,5));
shape.back()->setColor("red");
//3. 포인터객체
Shape* rect = new Rectangle(3,5);
rect->setColor("red");
shapes.push_back(rect);

//for (const auto& shape : shapes) {}
C++11 의 범위 기반 for루프(range-based for loop)로, 벡터에서 각 요소를 순회하는 구문
이다. 이 구문은 코드의 가독성을 높이고 오류를 줄이는데 유용하다. 
-const : 상수성(constancy)을 나타낸다. 즉, 루프 안에서 이 변수를 통해 요소값을 변경
할 수 없으믈 의미한다. 이는 각 요소를 읽기 전용으로 사용하고, 수정하지 않을 것이라는 
뜻이다.
-auto : 컴파일러가 변수의 타입을 자동으로 추론하도록 한다. shape변수의 타입은 shapes
벡터에 저장된 요소의 타입과 동일하게 된다. shapes벡터는 Shape* 타입의 요소를 저장하고
있으므로 shape변수의 타입은 Shape*&가 된다.
-& : 참조(reference)를 나타낸다. 요소를 복사하지 않고 참조를 통해 접근함으로써 성능을
높인다. 벡터에 큰 객체가 저장되어 있을 경우 유용하다. 여기서는 포인터(Shape)를 참조하므로
원본 데이터를 직접가리키게 된다.
-const auto&
-효율성 : 요소를 복사하지 않고 참조를 통해 접근하므로, 메모리 사용과 성능 면에서 효율적
-안전성 : const를 사용하여 루프 내에서 요소를 변경하지 않도록 보장한다. 의도하지 않은
변경을 방지하는 데 도움이 된다.
-가독성 : 코드가 간결하고 읽기 쉽다. 컴파일러가 타입을 추론하므로, 복잡한 타입 선언을 
명시할 필요가 없다.

//스마트포인터와 벡터를 사용
//main.cpp
#include <iostream>
#include <vector>
#include <memory>
#include "Shape.h"
#include "Rectangle.h"	
#include "Circle.h"	
#include "Triangle.h"

int main() {

	std::vector<std::unique_ptr<Shape>> shapes;

	shapes.push_back(std::make_unique<Rectangle>(3, 5));
	shapes.back()->setColor("red");

	shapes.push_back(std::make_unique<Circle>(2));
	shapes.back()->setColor("yellow");

	shapes.push_back(std::make_unique<Triangle>(3, 4));
	shapes.back()->setColor("blue");

	for (const auto& shape : shapes) {
		std::cout << shape->name() << "의 색상:" << shape->getColor() << std::endl;
		std::cout << shape->name() << "의 면적:" << shape->area() << std::endl;
		std::cout << shape->name() << "의 둘레:" << shape->perimeter() << std::endl;
	}

	return 0;
}

//1. std::unique_ptr 사용한 이유
- 메모리 관리의 자동화
스마트포인터로 소유권을 가진 객체가 파괴될 때 자동으로 메모리를 해제한다. 
이는 메모리 누수를 방지하고 명시적으로 delete를 호출할 필요가 없게한다.
{
std::unique_ptr<Rectangle> rect = std::make_unique<Rectangle>(3,5);
}
더이상 rect를 사용하지 않으면 범위를 벗어날 때 자동으로 메모리가 해제된다.
-소유권의 명확한 표현
단일 소유권을 강제한다. 특정 시점에 오직 하나의 unique_ptr만이 특정 자원을 소유할 수 있다.
복사되지 않으며 이동만 가능하다 이를 통해 소유권을 명확하게 표현할 수 있다.
std::unique_ptr<Shape> shape1 = std::make_unique<Rectangle>(3,5);
std::unique_ptr<Shape> shape2 = shape1; //불가능, 복사 금지
std::unique_ptr<Shape> shape2 = std::move(shape1); //가능, 이동을 통한 소유권 이전
-예외 안전성
예외가 발생해도 자원을 올바르게 해제할 수 있다. 예외 안정성을 제공하여 프로그램의 안정성을
높인다.
void createShape(){	
	std::vector<std::unique_ptr<Shape> shapes;
	shapes.push_back(std::make_unique<Rectangle>(3,5));
	//다른 작업 중 예외 발생 시 shapes가 파괴되면서 자동으로 메모리가 해제된다.
}
-명확한 코드
자원의 소유권과 수명을 명확하게 나타낼 수 있다. 코드의 가독성과 유지 보수성을 높인다.
