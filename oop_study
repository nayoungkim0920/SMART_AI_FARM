//클래스 다이아그램
+-----------------------------------+
|               Shape               |
+-----------------------------------+
| - color: std::string              |
+-----------------------------------+
| + Shape(color: std::string = "undefined") |
| + virtual area(): double          |
| + virtual perimeter(): double     |
| + virtual name(): std::string     |
| + setColor(color: std::string)   |
| + getColor(): std::string         |
+-----------------------------------+
            /\
            |
            |
            |
            |
            |
+-----------------------------------+
|            Rectangle              |
+-----------------------------------+
| - width: double                   |
| - height: double                  |
+-----------------------------------+
| + Rectangle(width: double, height: double, color: std::string = "undefined") |
| + area(): double override         |
| + perimeter(): double override    |
| + name(): std::string override    |
+-----------------------------------+

// Shape.h
#ifndef SHAPE_H
#define SHAPE_H

#include <string>

class Shape {
private:
	std::string color;
public:
	Shape(const std::string& color = "undefined");
	virtual double area() const = 0; //순수 가상 함수
	virtual double perimeter() const = 0; //순수 가상 함수
	virtual std::string name() const = 0; //순수 가상 함수
	virtual ~Shape(); //가상 소멸자

	void setColor(const std::string& color);
	std::string getColor() const;
};

#endif //SAHPE_H

//Shape.cpp
#include "Shape.h"

Shape::Shape(const std::string& color) : color(color) {
	std::cout << "Shape 생성자" << std::endl;
}

Shape::~Shape() {
	std::cout << "Shape 소멸자" << std::endl;
}

void Shape::setColor(const std::string& color)
{
	this->color = color;
}

std::string Shape::getColor() const
{
	return color;
}

//main.cpp
#include "Rectangle.h"
#include <iostream>

int main() {
	Shape* s = new Rectangle(3, 5);
	s->setColor("red");
	std::cout << s->getColor() << std::endl;
	delete s;
}

Shape 생성자
Rectangle 생성자
red
Rectangle 소멸자
Shape 소멸자

1. Shape.h
1) 헤더가드
#ifndef SHAPE_H,#define SHAPE_H,#endif //SAHPE_H
헤더파일이 여러 번 포함되는 것을 방지 하기 위해 사용된다.
컴파일 시간 오류를 방지하고 코드의 안정성을 높인다.
다중 포함을 방지하여 컴파일 오류를 피하고, 컴파일 시간을 줄이며, 코드의 
일관성을 유지하기 위해 사용된다.

2) 색상속성
private:
    std::string color;
도형의 색상을 나타내는 color 멤버 변수를 private로 선언하여 
직접 접근을 막고, 대신 public 멤버 함수를 통해 접근한다.
정보 은닉(Information Hiding)을 통해 데이터 무결성을 유지하고,
클래스의 인터페이스와 구현을 분리하여 유지보수성과 확장성을 높인다.

3) 생성자
public":
Sahpe(const std::string& color = "undefined") : color(color);
생성자는 객체가 생성될 때 호출되며, 기본적으로 색상을 undefined로 설정.
기본 값을 제공함으로써 객체 생성 시 불필요한 초기화 코드를 줄이고
사용 편의성을 높인다.
상수참조(const std::string&)는 매개변수를 상수 참조로 받는다.
-복사방지 : 문자열을 값으로 전달하면 복사가 일어난다. 복사는 시간과 메모리
측면에서 비효율적일 수 있다. 참조를 사용하면 이러한 복사를 피할 수 있다.
-불변성 : const 키워드를 사용하면 함수 내부에서 매개변수를 수정할 수 없게
되어 원본 데이터가 변경되지 않음을 보장한다.

4) 순수가상함수
virtual doble area() const = 0;
virtual double perimeter() const = 0;
virtual str::string name() const = 0;
Shape 클래스가 추상 클래스가 되게 하며, 상속받는 파생 클래스가 반드시
이 함수들을 구현하도록 강제한다.
-다형성(Polymorphism) : 순수 가상 함수를 사용하여, 동일한 인터페이스를 통해
다양한 도형 객체를 일관되게 처리할 수 있다.
-확장성 : 새로운 도형 클래스를 추가할 때, Shape클래스를 상속받아 필요한 함수
들을 구현하기만 하면 되므로, 기존 코드를 수정할 필요 없이 기능을 확장할 수
있다.
-유연성 : 프로그램이 구체적인 도형 클래스에 의존하지 않도록 하여, 변경에
유연하게 대응할 수 있다.

5) 가상 소멸자
virtual ~Shape()
파생 클래스와 객체가 올바르게 소멸되도록 보장한다.
기본 클래스 포인터로 파생 클래스 객체를 삭제할 때, 올바른 소멸자가 호출되어
메모리 누수를 방지하고 자원을 올바르게 해제할 수 있다.
추상클래스의 소멸자가 호출되면 파생클래스의 소멸자도 호출된다.

#include "Shape.h"
#include "Rectangle.h"

int main() {
	Shape* s = new Rectangle(3, 5);
	delete s;
}

Shape 생성자
Rectangle 생성자
Rectangle 소멸자
Shape 소멸자

6) 색상 설정 및 반환 함수
void setColor(const std::string& color){
	this->color = color;
}

std::string getColor() const{
	return color;
}

-캡슐화(Capsulation) : 멤버 변수에 직접 접근하는 것을 막고, 함수를 통해
안전하게 접근할 수 있도록 한다.
-유지보수성 : 멤버 변수를 변경할 때마다 다른 코드를 수정할 필요 없이, 
해당 함수만 수정하면 되므로 유지보수가 용이하다.

2. Shape.cpp
1) 헤더파일포함
#include "Shape.h"
Shape클래스의 선언이 포함되어 있다. 이 파일을 포함함으로써 Shape 클래스의 
정의와 멤버 함수 선언을 사용할 수 있다.

2)생성자 구현
Shape::Shape(const std::string& color) : color(color) {
	std::cout << "Shape 생성자" << std::endl;
}
도형의 초기색상을 설정한다. 생성자가 호출될 때 멤버 변수를 초기화하는 
효율적인 방법이다.

3)소멸자 구현
Shape::~Shape(){
	std::cout << "Shape 소멸자" << std::endl;
}
Shape클래스의 가상 소멸자이다. 파생클래스의 소멸자가 올바르게 호출되도록
보장한다. 이 소멸자는 Shape 객체가 소멸될 때 호출된다.

4)색상설정함수구현
void Shape::setColor(const std::string& color){
	this->color = color;
}
private멤버변수인 color변수를 설정한다. 매개변수로 받은 color값을 
this포인터를 사용하여 현재 객체의 color 멤버 변수에 할당한다. 
this포인터는 멤버 함수가 호출된 객체의 주소를 가리키는 특별한 포인터로
이를 통해 멤버 변수와 매개변수의 이름이 동일하더라도 구별할 수 있다.
하지만, 변수명을 겹치지않게하고 this를 사용하여 명확히 구분하는 방식을 
더 선호한다. 코드의 가독성을 높이고 유지보수성을 향상시키는 데 도움이되며
코드베이스의 일관성을 유지하는 데 도움이된다.
-> : 포인터가 가리키는 객체의 멤버에 접근하기 위해 사용된다.

//Circle 추가
+-----------------------------------+
|               Shape               |
+-----------------------------------+
| - color: std::string              |
+-----------------------------------+
| + Shape(color: std::string = "undefined") |
| + virtual area(): double          |
| + virtual perimeter(): double     |
| + virtual name(): std::string     |
| + setColor(color: std::string)   |
| + getColor(): std::string         |
+-----------------------------------+
            /\
            |
            |
            |
            |
            |
+-----------------------------------+
|            Rectangle              |
+-----------------------------------+
| - width: double                   |
| - height: double                  |
+-----------------------------------+
| + Rectangle(width: double, height: double, color: std::string = "undefined") |
| + area(): double override         |
| + perimeter(): double override    |
| + name(): std::string override    |
+-----------------------------------+
            /\
            |
            |
            |
            |
            |
+-----------------------------------+
|              Circle               |
+-----------------------------------+
| - radius: double                  |
+-----------------------------------+
| + Circle(radius: double, color: std::string = "undefined") |
| + area(): double override         |
| + perimeter(): double override    |
| + name(): std::string override    |
+-----------------------------------+


//Circle.h

#ifndef CIRCLE_H
#define CIRCLE_H

#include "Shape.h"

class Circle : public Shape {
private:
	double radius;
public:
	Circle(double radius, const std::string& color = "undefined");
	virtual double area() const override; 
	virtual double perimeter() const override; 
	virtual std::string name() const override;
	virtual ~Circle() override;
};

#endif //CIRCLE_H

//Circle.cpp
#include "Circle.h"
#include <iostream>

const double PI = 3.141592;

Circle::Circle(double radius, const std::string& color)
	: Shape(color), radius(radius)
{
	std::cout << "Circle 생성자" << std::endl;
}

double Circle::area() const
{
	return PI * radius * radius;
}

double Circle::perimeter() const
{
	return 2 * PI * radius;
}

std::string Circle::name() const
{
	return "Circle";
}

Circle::~Circle()
{
	std::cout << "Circle 소멸자" << std::endl;
}

//main.cpp
#include "Rectangle.h"
#include "Circle.h"
#include <iostream>

int main() {
	Shape* s[2];
	s[0] = new Rectangle(3, 5);
	s[0]->setColor("red");
	std::cout << s[0]->getColor() << std::endl;

	s[1] = new Circle(2, "yellow");
	std::cout << s[1]->getColor() << std::endl;

	delete s[0];
	delete s[1];
}

Shape 생성자
Rectangle 생성자
red
Shape 생성자
Circle 생성자
yellow
Rectangle 소멸자
Shape 소멸자
Circle 소멸자
Shape 소멸자

1) 생성자
Circle::Circle(double radius, const std::string& color)
	: Shape(color), radius(radius)
생성자 몸체에 진입 하기 전에 멤버 변수가 초기화되므로 효율적이다.

//순수가상함수
1)베이스 클래스 - Shapde.h
virtual std::string name() const = 0;
2)파생클래스(순수가상함수오버라이드) - Rectangle.h
virtual std::string name() const override;
3)파생 클래스 - Square.h
std::string name();
순수가상함수를 한번더 상속받는 경우에는 해당 함수를 다시 선언할 필요가없다.
이미 베이스클래스에서 순수가상함수로 선언되었기 때문에 파생클래스에서
다시 선언할 필요가 없다. 파생클래스가 이미 해당 함수를 오버라이딩해야하기
때문이다. 

//생성자
-Shape.h
Shape(const std::string& color = "undefined");
-Shape.cpp
Shape::Shape(const std::string& color) : color(color){}

-Rectangle.h
Rectangle(double w, double h, const std::string& color="undefined");
-Rectangle.cpp
Rectangle::Rectangle(double w, double h, const std::string& color) 
	:Shape(color), width(w), height(h) {}

-Square.h
Square(double side, const std::string& color = "undefined");
-Square.cpp
Square::Square(double side, const std::string& color)
	: Rectangle(side, side, color){}

//포인터, 스마트 포인터, 벡터
1. 포인터
-다형성지원 : 기본 클래스 포인터를 사용하여 다양한 파생 클래스 객체를 처리할 수 있다.
-객체수명제어 : 동적 할당과 해체를 통해 객체의 수명을 명확하게 제어할 수 있다. 
-메모리관리 : 동적으로 할당된 메로리를 명시적으로 해제해야하며 , 이를 잊으면 메모리 
누수가 발생할 수 있다.
-코드복잡성 : 포인터를 사용하면 코드가 복잡해질 수 있으며,메모리 관리 코드가 추가된다.
2. 스마트 포인터(std::unique_ptr, std::shared_ptr등)
포인터와 유사하지만 자동으로메모리를 관리한다.
-자동메모리관리 : 객체가 더이상 사용되지 않으면 자동으로 메모리가 해제된다.
-다형성지원 : 기본 클래스 포인터를 사용하여 다양한 파생 클래스 객체를 처리할 수 있다.
-안전성 : 메모리 누수를 방지할 수 있다.
-약간의 오버헤드 : 스마트 포인터는 포인터 관리 비용이 약간 더 발생할 수 있다.
-복잡한 구문 : 기본 포인터보다 구문이 조금 더 복잡할 수 있다.
3. 벡터(std::vector)
표준 템플릿 라이브러리(STL)의 컨테이너로 동적 배열을 제공한다.
-자동 크기 조절 : 벡터는 요소가 추가되면 자동으로 크기가 조절된다.
-간편한 메모리 관리 : 벡터는 요소를 자동으로 관리하며, 요소가 제거되면 자동으로 메모리를
해제한다.
-범위기반 for ㄹ프 : 범위 기반 for 루프를 사용하여 간편하게 요소를 순회할 수 있다.
-다형성 제한 : 벡터 자체는 다형성을 직접 지원하지 않으므로, 포인터를 사용하여 다형성을
구현해야한다.-
-메모리 오버헤드 : 벡터는 크기 조절을 위해 내부적으로 메모리를 할당하고 해제할 때 약간의
오버헤드가 발생할 수 있다.

//Triangle 확장하기
//Triangle.h
#include "Shape.h"

class Triangle : public Shape {
private:
	double base;
	double height;
public:
	Triangle(double base, double height, const std::string& color = "undefined");
	virtual double area() const override;
	virtual double perimeter() const override;
	virtual std::string name() const override;
	virtual ~Triangle() override;
};

//Triangle.cpp
#include "Triangle.h"
#include <iostream>

Triangle::Triangle(double base, double height, const std::string& color)
	: Shape(color), base(base), height(height) {
	std::cout << "Triangle 생성자" << std::endl;
}

double Triangle::area() const
{
	return 0.5 * base * height;
}

double Triangle::perimeter() const
{
	return 3 * base;
}

std::string Triangle::name() const
{
	return "Triangle";
}

Triangle::~Triangle()
{
	std::cout << "Triangle 소멸자" << std::endl;
}

//main.cpp
#include "Rectangle.h"
#include "Square.h"
#include "Triangle.h"
#include <iostream>
#include <vector>

int main() {

	std::vector<Shape*> shapes;

	shapes.push_back(new Rectangle(3, 5, "red"));
	shapes.push_back(new Square(2, "green"));
	shapes.push_back(new Triangle(3, 5, "yellow"));

	for (const auto& shape : shapes) {
		std::cout << shape->name() << "의 색상: " << shape->getColor() << std::endl;
		std::cout << shape->name() << "의 면적: " << shape->area() << std::endl;
		std::cout << shape->perimeter() << "의 둘레:" << shape->perimeter() << std::endl;
	}

	for (auto& shape : shapes) {
		delete shape;
	}

	shapes.clear();

	return 0;
}

//멤버함수호출방법
//1. 생성자
shapes.push_back(new Rectangle(3, 5, "red"));
//2. setColor() 호출
shape.push_back(new Rectangle(3,5));
shape.back()->setColor("red");
//3. 포인터객체
Shape* rect = new Rectangle(3,5);
rect->setColor("red");
shapes.push_back(rect);

//for (const auto& shape : shapes) {}
C++11 의 범위 기반 for루프(range-based for loop)로, 벡터에서 각 요소를 순회하는 구문
이다. 이 구문은 코드의 가독성을 높이고 오류를 줄이는데 유용하다. 
-const : 상수성(constancy)을 나타낸다. 즉, 루프 안에서 이 변수를 통해 요소값을 변경
할 수 없으믈 의미한다. 이는 각 요소를 읽기 전용으로 사용하고, 수정하지 않을 것이라는 
뜻이다.
-auto : 컴파일러가 변수의 타입을 자동으로 추론하도록 한다. shape변수의 타입은 shapes
벡터에 저장된 요소의 타입과 동일하게 된다. shapes벡터는 Shape* 타입의 요소를 저장하고
있으므로 shape변수의 타입은 Shape*&가 된다.
-& : 참조(reference)를 나타낸다. 요소를 복사하지 않고 참조를 통해 접근함으로써 성능을
높인다. 벡터에 큰 객체가 저장되어 있을 경우 유용하다. 여기서는 포인터(Shape)를 참조하므로
원본 데이터를 직접가리키게 된다.
-const auto&
-효율성 : 요소를 복사하지 않고 참조를 통해 접근하므로, 메모리 사용과 성능 면에서 효율적
-안전성 : const를 사용하여 루프 내에서 요소를 변경하지 않도록 보장한다. 의도하지 않은
변경을 방지하는 데 도움이 된다.
-가독성 : 코드가 간결하고 읽기 쉽다. 컴파일러가 타입을 추론하므로, 복잡한 타입 선언을 
명시할 필요가 없다.

//스마트포인터와 벡터를 사용
//main.cpp
#include <iostream>
#include <vector>
#include <memory>
#include "Shape.h"
#include "Rectangle.h"	
#include "Circle.h"	
#include "Triangle.h"

int main() {

	std::vector<std::unique_ptr<Shape>> shapes;

	shapes.push_back(std::make_unique<Rectangle>(3, 5));
	shapes.back()->setColor("red");

	shapes.push_back(std::make_unique<Circle>(2));
	shapes.back()->setColor("yellow");

	shapes.push_back(std::make_unique<Triangle>(3, 4));
	shapes.back()->setColor("blue");

	for (const auto& shape : shapes) {
		std::cout << shape->name() << "의 색상:" << shape->getColor() << std::endl;
		std::cout << shape->name() << "의 면적:" << shape->area() << std::endl;
		std::cout << shape->name() << "의 둘레:" << shape->perimeter() << std::endl;
	}

	return 0;
}

//1. std::unique_ptr 사용한 이유
- 메모리 관리의 자동화
스마트포인터로 소유권을 가진 객체가 파괴될 때 자동으로 메모리를 해제한다. 
이는 메모리 누수를 방지하고 명시적으로 delete를 호출할 필요가 없게한다.
{
std::unique_ptr<Rectangle> rect = std::make_unique<Rectangle>(3,5);
}
더이상 rect를 사용하지 않으면 범위를 벗어날 때 자동으로 메모리가 해제된다.
-소유권의 명확한 표현
단일 소유권을 강제한다. 특정 시점에 오직 하나의 unique_ptr만이 특정 자원을 소유할 수 있다.
복사되지 않으며 이동만 가능하다 이를 통해 소유권을 명확하게 표현할 수 있다.
std::unique_ptr<Shape> shape1 = std::make_unique<Rectangle>(3,5);
std::unique_ptr<Shape> shape2 = shape1; //불가능, 복사 금지
std::unique_ptr<Shape> shape2 = std::move(shape1); //가능, 이동을 통한 소유권 이전
-예외 안전성
예외가 발생해도 자원을 올바르게 해제할 수 있다. 예외 안정성을 제공하여 프로그램의 안정성을
높인다.
void createShape(){	
	std::vector<std::unique_ptr<Shape> shapes;
	shapes.push_back(std::make_unique<Rectangle>(3,5));
	//다른 작업 중 예외 발생 시 shapes가 파괴되면서 자동으로 메모리가 해제된다.
}
-명확한 코드
자원의 소유권과 수명을 명확하게 나타낼 수 있다. 코드의 가독성과 유지 보수성을 높인다.

//사용자로부터 도형의 종류와 속성을 입력받아 도형을 추가하고,
//추가된 도형들의 정보를 출력한다.
//ShapeManager.h
#ifndef SHAPESMANAGER_H
#define SHAPESMANAGER_H

#include <vector>
#include <memory>
#include "Shape.h"

class ShapeManager {
public:
	void addShape();
	void printShape() const; //해당 함수가 객체의 상태를 변경하지 않음을 보장

private:
	std::vector<std::unique_ptr<Shape>> shapes;
};

#endif //SHAPEMANAGER_H

//ShapeManager.cpp
#include "ShapesManager.h"
#include "Rectangle.h"
#include "Circle.h"
#include "Triangle.h"
#include <iostream>

void ShapeManager::addShape()
{
    int choice;
    while (true) {
        std::cout << "도형을 추가하세요 (1: Rectangle, 2: Circle, 3: Triangle, 0: 종료): ";
        std::cin >> choice;
        if (choice == 0) break;

        switch (choice) {
        case 1: {
            double width, height;
            std::string color;
            std::cout << "Rectangle의 너비, 높이, 색상 입력: ";
            std::cin >> width >> height >> color;
            auto rect = std::make_unique<Rectangle>(width, height, color);
            shapes.push_back(std::move(rect));
            std::cout << "Rectangle이 추가되었습니다." << std::endl;
            break;
        }
        case 2: {
            double radius;
            std::string color;
            std::cout << "Circle의 반지름, 색상 입력: ";
            std::cin >> radius >> color;
            auto circle = std::make_unique<Circle>(radius, color);
            shapes.push_back(std::move(circle));
            std::cout << "Circle이 추가되었습니다." << std::endl;
            break;
        }
        case 3: {
            double base, height, side1, side2, side3;
            std::string color;
            std::cout << "Triangle의 밑변, 높이, 세 변의 길이, 색상 입력: ";
            std::cin >> base >> height >> side1 >> side2 >> side3 >> std::ws; // std::ws를 사용하여 입력 버퍼를 비웁니다.
            std::getline(std::cin, color); // 개행 문자를 무시하고 나머지 입력을 받습니다.
            auto triangle = std::make_unique<Triangle>(base, height, side1, side2, side3, color);
            shapes.push_back(std::move(triangle));
            std::cout << "Triangle이 추가되었습니다." << std::endl;
            break;
        }

        default:
            std::cout << "잘못된 입력입니다. 다시 시도하세요." << std::endl;
            break;
        }
    }
}


void ShapeManager::printShape() const
{
	for (const auto& shape : shapes) {
		std::cout << shape->name() << "의 색상: " << shape->getColor() << std::endl;
		std::cout << shape->name() << "의 면적: " << shape->area() << std::endl;
		std::cout << shape->name() << "의 둘레: " << shape->perimeter() << std::endl;
	}
}

//main.cpp
#include "ShapesManager.h"

int main() {

	ShapeManager manager;

	manager.addShape();
	manager.printShape();

	return 0;
}

//출력
도형을 추가하세요 (1: Rectangle, 2: Circle, 3: Triangle, 0: 종료): 1
Rectangle의 너비, 높이, 색상 입력: 3 5 RED
Shape 생성자
Rectangle생성자
Rectangle이 추가되었습니다.
도형을 추가하세요 (1: Rectangle, 2: Circle, 3: Triangle, 0: 종료): 2
Circle의 반지름, 색상 입력: 2 GREEN
Shape 생성자
Circle 생성자
Circle이 추가되었습니다.
도형을 추가하세요 (1: Rectangle, 2: Circle, 3: Triangle, 0: 종료): 3
Triangle의 밑변, 높이, 세 변의 길이, 색상 입력: 1 2 3 4 5 YELLOW
Shape 생성자
Triangle 생성자
Triangle이 추가되었습니다.
도형을 추가하세요 (1: Rectangle, 2: Circle, 3: Triangle, 0: 종료): 0
Rectangle의 색상: RED
Rectangle의 면적: 15
Rectangle의 둘레: 16
Circle의 색상: GREEN
Circle의 면적: 12.5664
Circle의 둘레: 12.5664
Triangle의 색상: YELLOW
Triangle의 면적: 1
Triangle의 둘레: 12
Rectangle소멸자
Shape 소멸자
Circle 소멸자
Shape 소멸자
Triangle 소멸자
Shape 소멸자

//설명
- std::vector<std::unique_ptr<Shape>> shapes; 
1)Ownership및 동적 할당 관리
std::unique_ptr은 해당 포인터가 유일한 소유권을 가짐을 보장한다.
객체가 더 이상 필요하지 않을 때 자동으로 삭제된다.
소유권 개념을 활용하여 shapes 벡터는 동적으로 할당된 도형 객체들의 소유권을 가지게 된다.
이는 메모리 누수를 방지하고 안전하게 메모리를 관리할 수 있도록 한다.
2다형성지원(Polymorphism)
std::vector<std::unique_ptr<Shape>> shapes;
auto rect = std::make_unique<Rectangle>(width, height, color);
Shape클래스를 기반 클래스로 사용하여 다양한 도형 객체들을 하나의 벡터에 저장할 수 있다.
std::unique_ptr은 다형성을 지원하는 포인터로, 벡터에 저장된 다양한 도형 객체를 가리킬 
수 있다.
3)효율적인 메모리 관리
std::unique_ptr은 동적으로 할당된 객체에 대한 포인터를 가지며, 해당 객체의 생명 주기를 
자동으로 관리한다.
도형 객체가 벡터에서 제거될 때, 해당 객체의 메모리는 자동으로 해제되므로 메모리 누수를 
방지하고 메모리 관리를 효율적으로 할 수 있다.
4)Move 시멘틱스를 활용
std::uhique_ptr은 포인터가 유일한 소유권을 가지기 때문에 이동 시맨틱스를 지원한다.
따라서 객체를 복사하는 대신 이동하여 성능을 향상 시킬 수 있다.


//virtual ~Shape() = default;
가상 소멸자(virtual destructor)를 정의
virtual 키워드는 이 소멸자가 파생 클래스에서 오버라이딩할 수 있음을 나타냄
=default는 이 소멸자가 기본적인 동작을 갖도록 하겠다는것을 의미
상속 관계에서 객체가 파괴될 때 올바른 소멸자가 호출되도록 보장
컴파일러에게 해당 멤버 함수가 디폴트로 생성되도록 요청하는 것
해당 함수가 사용될 때까지 컴파일러가 정확히 어떻게 작동해야하는지 알 수 없을때 유용

// Shape.h
#ifndef SHAPE_H
#define SHAPE_H

#include <string>

class Shape {
public:
	virtual ~Shape() = default; //기본동작을함을알수있다.

	virtual double area() const = 0;
	virtual double perimeter() const = 0;
	virtual std::string name() const = 0;
	virtual std::string getColor() const = 0;
	virtual void setColor(const std::string& color) = 0;
};

#endif //SAHPE_H

//Rectangle.h
#ifndef RECTANGLE_H
#define RECTANGLE_H

#include "Shape.h"

//사각형 클래스9도형 클래스를 상속
class Rectangle : public Shape {
public:
	Rectangle(double width, double height, const std::string& color);
	~Rectangle() override = default;

	double area() const override;
	double perimeter() const override;
	std::string name() const override;
	std::string getColor() const override;
	void setColor(const std::string& color) override;

private:
	double width_;
	double height_;
	std::string color_;
};

#endif //RECTANGLE_H

//Rectangle.cpp
#include "Rectangle.h"

Rectangle::Rectangle(double width, double height, const std::string& color)
	: width_(width), height_(height), color_(color) {}

double Rectangle::area() const
{
	return width_ * height_;
}

double Rectangle::perimeter() const
{
	return 2 * (width_ + height_);
}

std::string Rectangle::name() const
{
	return "Rectangle";
}

std::string Rectangle::getColor() const
{
	return color_;
}

void Rectangle::setColor(const std::string& color)
{
	color_ = color;
}

//Circle.h
#ifndef CIRCLE_H
#define CIRCLE_H

#define M_PI 3.14159265358979323846

#include "Shape.h"

class Circle : public Shape {
public:
	Circle(double radius, const std::string& color);
	~Circle() override = default; //기본동작을함을알수있다.

	double area() const override;
	double perimeter() const override;
	std::string name() const override;
	std::string getColor() const override;
	void setColor(const std::string& color) override;

private:
	double radius_;
	std::string color_;
};

#endif //CIRCLE_H

//Circle.cpp
#include "Circle.h"

Circle::Circle(double radius, const std::string& color)
	: radius_(radius), color_(color) {}

double Circle::area() const
{
	return M_PI * radius_ * radius_;
}

double Circle::perimeter() const
{
	return 2 * M_PI * radius_;
}

std::string Circle::name() const
{
	return "Circle";
}

std::string Circle::getColor() const
{
	return color_;
}

void Circle::setColor(const std::string& color)
{
	color_ = color;
}

//Triangle.h
#ifndef TRIANGLE_H
#define TRIANGLE_H

#include "Shape.h"

class Triangle : public Shape {
public:
	Triangle(double base, double height, double side1, double side2, double side3, const std::string& color);
	~Triangle() override = default; //기본동작을함을알수있다.

	double area() const override;
	double perimeter() const override;
	std::string name() const override;
	std::string getColor() const override;
	void setColor(const std::string& color) override;
private:
	double base_;
	double height_;
	double side1_;
	double side2_;
	double side3_;
	std::string color_;
};

#endif //TRIANGLE_H

//Triangle.cpp

#include "Triangle.h"

Triangle::Triangle(double base, double height, double side1, double side2, double side3, const std::string& color)
	: base_(base), height_(height), side1_(side1), side2_(side2), side3_(side3), color_(color) {}

double Triangle::area() const
{
	//삼각형 넓이(헤론의공식)
	double s = (side1_ + side2_ + side3_) / 2.0;
	return sqrt(s * (s - side1_) *(s-side2_)*(s-side3_));
}

double Triangle::perimeter() const
{
	return side1_ + side2_ + side3_;
}

std::string Triangle::name() const
{
	return "Triangle";
}

std::string Triangle::getColor() const
{
	return color_;
}

void Triangle::setColor(const std::string& color)
{
	color_ = color;
}

//ShapeManager.h
#ifndef SHAPESMANAGER_H
#define SHAPESMANAGER_H

#include <vector>
#include <memory>
#include "Shape.h"

class ShapeManager {
public:
	void addShape();
	void printShape() const; //해당 함수가 객체의 상태를 변경하지 않음을 보장

private:
	std::vector<std::unique_ptr<Shape>> shapes;
};

#endif //SHAPESMANAGER_H

//ShapeManager.cpp
#include "ShapesManager.h"
#include "Rectangle.h"
#include "Circle.h"
#include "Triangle.h"
#include <iostream>

void ShapeManager::addShape()
{
    int choice;
    while (true) {
        std::cout << "도형을 추가하세요 (1: Rectangle, 2: Circle, 3: Triangle, 0: 종료): ";
        std::cin >> choice;
        if (choice == 0) break;

        switch (choice) {
        case 1: {
            double width, height;
            std::string color;
            std::cout << "Rectangle의 너비, 높이, 색상 입력: ";
            std::cin >> width >> height >> color;
            auto rect = std::make_unique<Rectangle>(width, height, color);
            shapes.push_back(std::move(rect));
            std::cout << "Rectangle이 추가되었습니다." << std::endl;
            break;
        }
        case 2: {
            double radius;
            std::string color;
            std::cout << "Circle의 반지름, 색상 입력: ";
            std::cin >> radius >> color;
            auto circle = std::make_unique<Circle>(radius, color);
            shapes.push_back(std::move(circle));
            std::cout << "Circle이 추가되었습니다." << std::endl;
            break;
        }
        case 3: {
            double base, height, side1, side2, side3;
            std::string color;
            std::cout << "Triangle의 밑변, 높이, 세 변의 길이, 색상 입력: ";
            std::cin >> base >> height >> side1 >> side2 >> side3 >> std::ws; // std::ws를 사용하여 입력 버퍼를 비웁니다.
            std::getline(std::cin, color); // 개행 문자를 무시하고 나머지 입력을 받습니다.
            auto triangle = std::make_unique<Triangle>(base, height, side1, side2, side3, color);
            shapes.push_back(std::move(triangle));
            std::cout << "Triangle이 추가되었습니다." << std::endl;
            break;
        }

        default:
            std::cout << "잘못된 입력입니다. 다시 시도하세요." << std::endl;
            break;
        }
    }
}


void ShapeManager::printShape() const
{
	for (const auto& shape : shapes) {
		std::cout << shape->name() << "의 색상: " << shape->getColor() << std::endl;
		std::cout << shape->name() << "의 면적: " << shape->area() << std::endl;
		std::cout << shape->name() << "의 둘레: " << shape->perimeter() << std::endl;
	}
}

//main.cpp
#include "ShapesManager.h"

int main() {

	ShapeManager manager;

	manager.addShape();
	manager.printShape();

	return 0;
}


//다각형 추가, 도형삭제기능 추가
//1. Polygon.h, Polygon.cpp 추가
//2. ShapeManager.h, ShapeManager.cpp 변경/추가

//Polygon.h
#ifndef POLYGON_H
#define POLYGON_H

#include "Shape.h"
#include <vector>

class Polygon : public Shape {
public:
	Polygon(const std::vector<double>& sides, const std::string& color);
	~Polygon() override = default; //기본동작을함을알수있다.

	double area() const override;
	double perimeter() const override;
	std::string name() const override;
	std::string getColor() const override;
	void setColor(const std::string& color) override;

private:
	std::vector<double> sides_;
	std::string color_;
};

#endif //POLYGON_H

//Polygon.cpp
#include "Polygon.h"

// Polygon 클래스의 생성자
Polygon::Polygon(const std::vector<double>& sides, const std::string& color)
    : sides_(sides), color_(color) {}

// 면적을 계산하는 함수 (단순한 경우로, 예를 들어 모든 변이 같은 정다각형일 때)
double Polygon::area() const {
    // 일반적인 다각형의 면적을 계산하기 위한 방법이 복잡하므로 여기서는 정다각형의 면적을 예로 들겠습니다.
    int n = sides_.size();
    if (n < 3) return 0; // 삼각형 이하일 경우 면적은 0
    double side_length = sides_[0]; // 모든 변이 같다고 가정
    double apothem = side_length / (2 * tan(M_PI / n));
    return (n * side_length * apothem) / 2;
}

// 둘레를 계산하는 함수
double Polygon::perimeter() const {
    double perimeter = 0;
    for (double side : sides_) {
        perimeter += side;
    }
    return perimeter;
}

// 도형의 이름을 반환하는 함수
std::string Polygon::name() const {
    return "Polygon";
}

// 색상을 반환하는 함수
std::string Polygon::getColor() const {
    return color_;
}

// 색상을 설정하는 함수
void Polygon::setColor(const std::string& color) {
    color_ = color;
}

//ShapeManager.h
#ifndef SHAPESMANAGER_H
#define SHAPESMANAGER_H

#include <vector>
#include <memory>
#include "Shape.h"

class ShapeManager {
public:
	void addShape(); //도형추가
	void printShape() const; //해당 함수가 객체의 상태를 변경하지 않음을 보장
	void removeShape(); //도형삭제
private:
	std::vector<std::unique_ptr<Shape>> shapes;
};

#endif //SHAPESMANAGER_H

//ShapeManager.cpp
#include "ShapesManager.h"
#include "Rectangle.h"
#include "Circle.h"
#include "Triangle.h"
#include "Polygon.h"
#include <iostream>
#include <iomanip> //소수점 출력

void ShapeManager::addShape()
{
    int choice;
    while (true) {
        std::cout << "도형을 추가하세요 (1: Rectangle, 2: Circle, 3: Triangle, 4:Polygon 0: 종료): ";
        std::cin >> choice;
        if (choice == 0) break;

        switch (choice) {
        case 1: {
            double width, height;
            std::string color;
            std::cout << "Rectangle의 너비, 높이, 색상 입력: ";
            std::cin >> width >> height >> color;
            auto rect = std::make_unique<Rectangle>(width, height, color);
            shapes.push_back(std::move(rect));
            std::cout << "Rectangle이 추가되었습니다." << std::endl;
            break;
        }
        case 2: {
            double radius;
            std::string color;
            std::cout << "Circle의 반지름, 색상 입력: ";
            std::cin >> radius >> color;
            auto circle = std::make_unique<Circle>(radius, color);
            shapes.push_back(std::move(circle));
            std::cout << "Circle이 추가되었습니다." << std::endl;
            break;
        }
        case 3: {
            double base, height, side1, side2, side3;
            std::string color;
            std::cout << "Triangle의 밑변, 높이, 세 변의 길이, 색상 입력: ";
            std::cin >> base >> height >> side1 >> side2 >> side3 >> std::ws; // std::ws를 사용하여 입력 버퍼를 비웁니다.
            std::getline(std::cin, color); // 개행 문자를 무시하고 나머지 입력을 받습니다.
            auto triangle = std::make_unique<Triangle>(base, height, side1, side2, side3, color);
            shapes.push_back(std::move(triangle));
            std::cout << "Triangle이 추가되었습니다." << std::endl;
            break;
        }
        case 4: {
            int n;
            std::cout << "Polygon의 변의 개수 입력: ";
            while (!(std::cin >> n) || n < 3) { // n이 유효한 값인지 확인
                std::cout << "유효한 변의 개수를 입력하십시오 (3 이상의 정수): ";
                std::cin.clear(); // 입력 스트림의 오류 상태를 지움
                std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // 버퍼를 비움
            }

            std::vector<double> sides(n);
            std::string color;
            std::cout << "Polygon의 각 변의 길이와 색상 입력: ";
            for (int i = 0; i < n; ++i) {
                while (!(std::cin >> sides[i])) { // 각 변의 길이가 유효한 값인지 확인
                    std::cout << "유효한 변의 길이를 입력하십시오: ";
                    std::cin.clear();
                    std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
                }
            }
            std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n'); // 남아있는 '\n'를 무시
            std::getline(std::cin, color); // 색상을 입력받음

            auto polygon = std::make_unique<Polygon>(sides, color);
            shapes.push_back(std::move(polygon));
            std::cout << "Polygon이 추가되었습니다." << std::endl;
            break;
        }

        default:
            std::cout << "잘못된 입력입니다. 다시 시도하세요." << std::endl;
            break;
        }
    }
}


void ShapeManager::printShape() const
{
    if (shapes.empty()) {
        std::cout << "추가된 도형이 없습니다." << std::endl;
        return;
    }

    std::cout << "추가된 도형 정보:" << std::endl;

	for (const auto& shape : shapes) {
		std::cout << shape->name() << "의 색상: " << shape->getColor() << std::endl;
		std::cout << shape->name() << "의 면적: " << std::fixed << std::setprecision(2) << shape->area() << std::endl;
		std::cout << shape->name() << "의 둘레: " << std::fixed << std::setprecision(2) << shape->perimeter() << std::endl;
	}
}

void ShapeManager::removeShape()
{
    int index;
    std::cout << "삭제할 도형의 인덱스 입력: ";
    std::cin >> index;
    if (index >= 0 && index < shapes.size()) {
        shapes.erase(shapes.begin() + index);
        std::cout << "도형이 삭제되었습니다." << std::endl;
    }
    else {
        std::cout << "잘못된 인덱스입니다." << std::endl;
    }
}

//결과
1:도형추가, 2:도형출력, 3:도형삭제, 0:종료:1
도형을 추가하세요 (1: Rectangle, 2: Circle, 3: Triangle, 4:Polygon 0: 종료): 4
Polygon의 변의 개수 입력: 4
Polygon의 각 변의 길이와 색상 입력: 5.0 5.0 5.0 5.0
red
Polygon이 추가되었습니다.
도형을 추가하세요 (1: Rectangle, 2: Circle, 3: Triangle, 4:Polygon 0: 종료): 0
1:도형추가, 2:도형출력, 3:도형삭제, 0:종료:2
추가된 도형 정보:
Polygon의 색상: red
Polygon의 면적: 25.00
Polygon의 둘레: 20.00
1:도형추가, 2:도형출력, 3:도형삭제, 0:종료:3
삭제할 도형의 인덱스 입력: 0
도형이 삭제되었습니다.
1:도형추가, 2:도형출력, 3:도형삭제, 0:종료:2
추가된 도형이 없습니다.
1:도형추가, 2:도형출력, 3:도형삭제, 0:종료:0
+-----------------------+
|      <<interface>>    |
|         Shape         |
+-----------------------+
| - color: string       |
+-----------------------+
| + virtual area(): double |
| + virtual perimeter(): double |
| + virtual name(): string |
| + virtual getColor(): string |
| + virtual setColor(color: string): void |
+-----------------------+
            |
            | implements
            |
+------------------------+
|        Rectangle       |
+------------------------+
| - width: double        |
| - height: double       |
+------------------------+
| + Rectangle(width: double, height: double, color: string) |
| + area(): double |
| + perimeter(): double |
| + name(): string |
| + getColor(): string |
| + setColor(color: string): void |
+------------------------+
            |
            | extends
            |
+------------------------+
|         Circle         |
+------------------------+
| - radius: double       |
+------------------------+
| + Circle(radius: double, color: string) |
| + area(): double |
| + perimeter(): double |
| + name(): string |
| + getColor(): string |
| + setColor(color: string): void |
+------------------------+
            |
            | extends
            |
+------------------------+
|        Triangle        |
+------------------------+
| - base: double         |
| - height: double       |
| - side1: double        |
| - side2: double        |
| - side3: double        |
+------------------------+
| + Triangle(base: double, height: double, side1: double, side2: double, side3: double, color: string) |
| + area(): double |
| + perimeter(): double |
| + name(): string |
| + getColor(): string |
| + setColor(color: string): void |
+------------------------+
            |
            | extends
            |
+------------------------+
|         Polygon         |
+------------------------+
| - sides: vector<double> |
+------------------------+
| + Polygon(sides: vector<double>, color: string) |
| + area(): double |
| + perimeter(): double |
| + name(): string |
| + getColor(): string |
| + setColor(color: string): void |
+------------------------+
